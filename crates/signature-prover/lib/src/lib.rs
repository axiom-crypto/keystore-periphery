use clap::Parser;

use crate::{build_guest::BuildGuestArgs, keygen::KeygenArgs};

/// Command to build the guest program into a RISC-V ELF.
pub mod build_guest;
/// CLI args and methods to generate proving key and verifying key data for signature prover circuit.
pub mod keygen;
/// The [ProverContext] struct holds the data (proving keys, committed program exe) about the
/// signature prover circuit in memory for use to generate signature proofs. This struct is meant
/// to be imported and used inside proving server implementations.
mod prover_context;
/// Utilities for writing tests for signature prover implementations.
#[cfg(feature = "test-utils")]
pub mod test_utils;

pub use keygen::keygen;
pub use prover_context::ProverContext;

/// These public values are constants for all OpenVM aggregation halo2 proofs generated by the signature prover.
/// All public values that are passed into the OpenVM guest program are checked for consistency and stored in
/// fixed halo2 columns, but are not exposed as public values in the final halo2 proof.
pub const NUM_USER_PUBLIC_VALUES_BYTES: usize = 64; // 2 hashes x 32 bytes
pub const NUM_OUTPUT_PVS: usize = 16; // 12 accumulator + 2 Hi-Lo

/// Command line arguments to build guest program and generate
/// proving and verifying keys.
///
/// The build command is the same as the build command in the `cargo-openvm` crate. We re-export it here as a convenience to ensure versioning is consistent.
#[derive(Parser, Clone)]
pub struct BuildAndKeygenArgs {
    #[clap(flatten)]
    pub guest: BuildGuestArgs,

    #[clap(flatten)]
    pub keygen: KeygenArgs,

    #[arg(long = "log-format", value_name = "FORMAT", default_value_t = LogFormat::Terminal)]
    pub log_format: LogFormat,
}

#[derive(Debug, Clone, Copy, clap::ValueEnum)]
pub enum LogFormat {
    Json,
    Terminal,
}

impl Default for LogFormat {
    fn default() -> Self {
        Self::Terminal
    }
}

impl std::fmt::Display for LogFormat {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match self {
            LogFormat::Json => write!(f, "json"),
            LogFormat::Terminal => write!(f, "terminal"),
        }
    }
}

pub fn init_logging(logfmt: LogFormat) {
    let env_filter = tracing_subscriber::EnvFilter::builder()
        .with_default_directive(tracing::Level::INFO.into())
        .from_env_lossy();

    let subscriber_builder = tracing_subscriber::fmt()
        .with_ansi(false)
        .with_env_filter(env_filter)
        .with_file(true)
        .with_line_number(true)
        .with_thread_ids(true)
        .with_target(false);

    match logfmt {
        LogFormat::Json => {
            let subscriber = subscriber_builder.json();
            subscriber.init();
        }
        LogFormat::Terminal => {
            let subscriber = subscriber_builder;
            subscriber.init();
        }
    }
}
